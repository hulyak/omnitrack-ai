/**
 * Property-based tests for Hackathon Demo - IoT Data Persistence
 * 
 * Feature: hackathon-aws-demo, Property 2: IoT data persistence
 * Validates: Requirements 2.1
 */

import * as fc from 'fast-check';

// Mock AWS SDK clients
jest.mock('@aws-sdk/client-dynamodb');
jest.mock('@aws-sdk/lib-dynamodb', () => {
  return {
    DynamoDBDocumentClient: {
      from: jest.fn(() => ({
        send: jest.fn()
      }))
    },
    PutCommand: jest.fn(),
    GetCommand: jest.fn(),
    QueryCommand: jest.fn()
  };
});

/**
 * Property 2: IoT data persistence
 * 
 * For any sensor data generated by the IoT Simulator, 
 * the system should successfully store the data in DynamoDB 
 * with all required fields.
 */

// In-memory storage for testing
const mockDynamoDBStorage = new Map<string, any>();

// Simulated DynamoDB operations
const putItem = async (item: any): Promise<void> => {
  const key = `${item.PK}#${item.SK}`;
  mockDynamoDBStorage.set(key, item);
};

const getItem = async (pk: string, sk: string): Promise<any | null> => {
  const key = `${pk}#${sk}`;
  return mockDynamoDBStorage.get(key) || null;
};

// IoT data processor that stores sensor data
const processIoTSensorData = async (sensorData: any): Promise<any> => {
  // Validate required fields
  if (!sensorData.sensorId || !sensorData.nodeId || !sensorData.type || sensorData.value === undefined) {
    throw new Error('Missing required fields');
  }

  const timestamp = Date.now();
  const item = {
    PK: `SENSOR#${sensorData.sensorId}`,
    SK: `DATA#${timestamp}`,
    sensorId: sensorData.sensorId,
    nodeId: sensorData.nodeId,
    type: sensorData.type,
    value: sensorData.value,
    threshold: sensorData.threshold,
    unit: sensorData.unit,
    timestamp,
    metadata: sensorData.metadata || {},
    createdAt: new Date().toISOString()
  };

  // Store in DynamoDB
  await putItem(item);

  return item;
};

describe('Demo Property Tests - IoT Data Persistence', () => {
  beforeEach(() => {
    mockDynamoDBStorage.clear();
  });

  describe('Property 2: IoT data persistence', () => {
    it('should store all sensor data with required fields in DynamoDB', async () => {
      // Generator for valid sensor data
      const sensorDataArb = fc.record({
        sensorId: fc.uuid(),
        nodeId: fc.uuid(),
        type: fc.constantFrom('temperature', 'delay', 'inventory', 'humidity', 'pressure'),
        value: fc.double({ min: -100, max: 1000, noNaN: true }),
        threshold: fc.double({ min: 0, max: 1000, noNaN: true }),
        unit: fc.constantFrom('celsius', 'fahrenheit', 'hours', 'units', 'percent', 'psi'),
        metadata: fc.record({
          location: fc.string({ minLength: 2, maxLength: 50 }),
          deviceModel: fc.string({ minLength: 3, maxLength: 30 }),
          firmwareVersion: fc.string({ minLength: 3, maxLength: 20 })
        })
      });

      await fc.assert(
        fc.asyncProperty(sensorDataArb, async (sensorData) => {
          mockDynamoDBStorage.clear();

          // Process and store the sensor data
          const storedItem = await processIoTSensorData(sensorData);

          // Verify the item was stored
          expect(storedItem).toBeDefined();
          expect(storedItem.PK).toBe(`SENSOR#${sensorData.sensorId}`);
          expect(storedItem.SK).toMatch(/^DATA#\d+$/);

          // Verify all required fields are present
          expect(storedItem.sensorId).toBe(sensorData.sensorId);
          expect(storedItem.nodeId).toBe(sensorData.nodeId);
          expect(storedItem.type).toBe(sensorData.type);
          expect(storedItem.value).toBe(sensorData.value);
          expect(storedItem.threshold).toBe(sensorData.threshold);
          expect(storedItem.unit).toBe(sensorData.unit);
          expect(storedItem.timestamp).toBeDefined();
          expect(storedItem.createdAt).toBeDefined();

          // Verify metadata is preserved
          expect(storedItem.metadata).toEqual(sensorData.metadata);

          // Verify we can retrieve the stored data
          const retrievedItem = await getItem(storedItem.PK, storedItem.SK);
          expect(retrievedItem).toEqual(storedItem);
        }),
        { numRuns: 100 } // Run 100 iterations as specified in design doc
      );
    }, 30000);

    it('should handle different sensor types correctly', async () => {
      // Generator for various sensor types
      const temperatureSensorArb = fc.record({
        sensorId: fc.uuid(),
        nodeId: fc.uuid(),
        type: fc.constant('temperature'),
        value: fc.double({ min: -50, max: 150, noNaN: true }),
        threshold: fc.double({ min: 0, max: 100, noNaN: true }),
        unit: fc.constantFrom('celsius', 'fahrenheit'),
        metadata: fc.record({
          location: fc.string({ minLength: 2, maxLength: 50 })
        })
      });

      const inventorySensorArb = fc.record({
        sensorId: fc.uuid(),
        nodeId: fc.uuid(),
        type: fc.constant('inventory'),
        value: fc.integer({ min: 0, max: 100000 }),
        threshold: fc.integer({ min: 0, max: 10000 }),
        unit: fc.constant('units'),
        metadata: fc.record({
          location: fc.string({ minLength: 2, maxLength: 50 })
        })
      });

      const delaySensorArb = fc.record({
        sensorId: fc.uuid(),
        nodeId: fc.uuid(),
        type: fc.constant('delay'),
        value: fc.double({ min: 0, max: 168, noNaN: true }), // Up to 1 week in hours
        threshold: fc.double({ min: 0, max: 24, noNaN: true }),
        unit: fc.constant('hours'),
        metadata: fc.record({
          location: fc.string({ minLength: 2, maxLength: 50 })
        })
      });

      const sensorArb = fc.oneof(temperatureSensorArb, inventorySensorArb, delaySensorArb);

      await fc.assert(
        fc.asyncProperty(sensorArb, async (sensorData) => {
          mockDynamoDBStorage.clear();

          // Process and store the sensor data
          const storedItem = await processIoTSensorData(sensorData);

          // Verify type-specific constraints
          expect(storedItem.type).toBe(sensorData.type);
          expect(storedItem.value).toBe(sensorData.value);
          expect(storedItem.unit).toBe(sensorData.unit);

          // Verify data integrity
          const retrievedItem = await getItem(storedItem.PK, storedItem.SK);
          expect(retrievedItem).toBeDefined();
          expect(retrievedItem.type).toBe(sensorData.type);
          expect(retrievedItem.value).toBe(sensorData.value);
        }),
        { numRuns: 100 }
      );
    }, 30000);

    it('should maintain data integrity for concurrent sensor writes', async () => {
      // Generator for multiple sensors from the same node
      const sensorBatchArb = fc.array(
        fc.record({
          sensorId: fc.uuid(),
          nodeId: fc.constant('node-123'), // Same node for all sensors
          type: fc.constantFrom('temperature', 'delay', 'inventory'),
          value: fc.double({ min: 0, max: 1000, noNaN: true }),
          threshold: fc.double({ min: 0, max: 1000, noNaN: true }),
          unit: fc.constantFrom('celsius', 'hours', 'units'),
          metadata: fc.record({
            location: fc.constant('warehouse-a')
          })
        }),
        { minLength: 1, maxLength: 10 }
      );

      await fc.assert(
        fc.asyncProperty(sensorBatchArb, async (sensorBatch) => {
          mockDynamoDBStorage.clear();

          // Process all sensors concurrently
          const storedItems = await Promise.all(
            sensorBatch.map(sensor => processIoTSensorData(sensor))
          );

          // Verify all items were stored
          expect(storedItems.length).toBe(sensorBatch.length);

          // Verify each item can be retrieved
          for (const storedItem of storedItems) {
            const retrievedItem = await getItem(storedItem.PK, storedItem.SK);
            expect(retrievedItem).toBeDefined();
            expect(retrievedItem.sensorId).toBe(storedItem.sensorId);
            expect(retrievedItem.nodeId).toBe(storedItem.nodeId);
          }

          // Verify no data was lost or corrupted
          expect(mockDynamoDBStorage.size).toBe(sensorBatch.length);
        }),
        { numRuns: 100 }
      );
    }, 30000);

    it('should reject sensor data with missing required fields', async () => {
      // Generator for invalid sensor data (missing required fields)
      const invalidSensorArb = fc.oneof(
        // Missing sensorId
        fc.record({
          nodeId: fc.uuid(),
          type: fc.constantFrom('temperature', 'delay', 'inventory'),
          value: fc.double({ min: 0, max: 1000, noNaN: true }),
          threshold: fc.double({ min: 0, max: 1000, noNaN: true }),
          unit: fc.string()
        }),
        // Missing nodeId
        fc.record({
          sensorId: fc.uuid(),
          type: fc.constantFrom('temperature', 'delay', 'inventory'),
          value: fc.double({ min: 0, max: 1000, noNaN: true }),
          threshold: fc.double({ min: 0, max: 1000, noNaN: true }),
          unit: fc.string()
        }),
        // Missing type
        fc.record({
          sensorId: fc.uuid(),
          nodeId: fc.uuid(),
          value: fc.double({ min: 0, max: 1000, noNaN: true }),
          threshold: fc.double({ min: 0, max: 1000, noNaN: true }),
          unit: fc.string()
        })
      );

      await fc.assert(
        fc.asyncProperty(invalidSensorArb, async (invalidData) => {
          mockDynamoDBStorage.clear();

          // Attempt to process invalid data should throw error
          await expect(processIoTSensorData(invalidData)).rejects.toThrow('Missing required fields');

          // Verify nothing was stored
          expect(mockDynamoDBStorage.size).toBe(0);
        }),
        { numRuns: 100 }
      );
    }, 30000);

    it('should preserve timestamp ordering for sequential sensor readings', async () => {
      // Generator for sequential sensor readings from the same sensor
      const sensorIdArb = fc.uuid();

      await fc.assert(
        fc.asyncProperty(sensorIdArb, async (sensorId) => {
          mockDynamoDBStorage.clear();

          const readings = [];
          const numReadings = 5;

          // Generate sequential readings
          for (let i = 0; i < numReadings; i++) {
            const reading = {
              sensorId,
              nodeId: 'node-123',
              type: 'temperature' as const,
              value: 20 + i,
              threshold: 30,
              unit: 'celsius',
              metadata: { reading: i }
            };

            // Small delay to ensure timestamp ordering
            await new Promise(resolve => setTimeout(resolve, 2));
            
            const storedItem = await processIoTSensorData(reading);
            readings.push(storedItem);
          }

          // Verify timestamps are in ascending order
          for (let i = 1; i < readings.length; i++) {
            expect(readings[i].timestamp).toBeGreaterThan(readings[i - 1].timestamp);
          }

          // Verify all readings were stored
          expect(mockDynamoDBStorage.size).toBe(numReadings);
        }),
        { numRuns: 20 } // Fewer runs due to sequential delays
      );
    }, 30000);
  });
});
